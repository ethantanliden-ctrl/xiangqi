<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>中国象棋 - 本地单机/双人（含悔棋、音效、AI）</title>
  <style>
    :root{ --cell:66px; --board-width: calc(var(--cell) * 9); --theme-brown:#8b5e3c; --theme-light:#f7e1b8; }
    *{box-sizing:border-box}
    body{font-family: 'Noto Sans SC', system-ui, sans-serif; display:flex; flex-direction:column; align-items:center; gap:14px; padding:18px; background:linear-gradient(180deg,#efe5c6,#f8f1dd);} 
    h1{margin:0;color:#5b3a23}
    .controls{width:var(--board-width);display:flex;justify-content:space-between;align-items:center;gap:10px}
    .left, .right{display:flex;gap:8px;align-items:center}
    button{padding:8px 12px;border-radius:8px;border:none;background:var(--theme-brown);color:#fff;cursor:pointer}
    button.secondary{background:#6b8b6b}
    #status{font-weight:700}
    #board{width:var(--board-width);height:calc(var(--cell)*10);display:grid;grid-template-columns:repeat(9,1fr);grid-template-rows:repeat(10,1fr);border:8px solid var(--theme-brown);border-radius:10px;background:var(--theme-light);box-shadow:0 8px 28px rgba(0,0,0,0.18)}
    .cell{border:1px solid rgba(0,0,0,0.08);display:flex;align-items:center;justify-content:center;cursor:pointer;position:relative;transition:background .12s,transform .08s}
    .cell.sel{outline:3px solid rgba(58,143,243,0.9)}
    .cell.move{background:rgba(60,200,60,0.15)}
    .cell.capture::after{content:'';position:absolute;width:12px;height:12px;border-radius:50%;background:rgba(200,0,0,0.85);right:6px;bottom:6px}
    .piece{font-weight:800;font-size:30px}
    .red{color:#c62828}
    .black{color:#231f20}
    #modal{position:fixed;inset:0;background:rgba(0,0,0,0.55);display:none;align-items:center;justify-content:center;z-index:50}
    .dialog{background:#fff;padding:20px 26px;border-radius:10px;text-align:center;box-shadow:0 10px 30px rgba(0,0,0,0.28)}
    .small{font-size:13px;color:#444}
  </style>
</head>
<body>
  <h1>中国象棋</h1>
  <div class="controls">
    <div class="left">
      <div id="status">轮到：红方</div>
      <button id="undo" class="secondary">悔棋</button>
      <button id="restart">重新开始</button>
      <button id="flip">翻转视角</button>
    </div>

    <div class="right">
      <label class="small">模式：</label>
      <select id="mode">
        <option value="hotseat">本地双人</option>
        <option value="ai">单人 vs AI（AI执黑）</option>
      </select>
      <button id="mute">静音</button>
    </div>
  </div>

  <div id="board" aria-label="象棋棋盘"></div>

  <div id="modal"><div class="dialog"><h2 id="winnerText"></h2><div style="margin-top:12px"><button id="again">再来一局</button></div></div></div>

  <!-- 音效（内置短音频 base64 简短占位） -->
  <audio id="moveAudio"><source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=" type="audio/wav"></audio>
  <audio id="captureAudio"><source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=" type="audio/wav"></audio>
  <audio id="winAudio"><source src="data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEAESsAACJWAAACABAAZGF0YQAAAAA=" type="audio/wav"></audio>

  <script>
    // 简化的单文件象棋（含悔棋、音效、随机AI）
    const PIECE_MAP={R:'車',N:'馬',B:'相',A:'仕',K:'帥',C:'炮',P:'兵',r:'車',n:'馬',b:'象',a:'士',k:'將',c:'砲',p:'卒'};
    const boardEl=document.getElementById('board');
    const status=document.getElementById('status');
    const undoBtn=document.getElementById('undo');
    const restartBtn=document.getElementById('restart');
    const flipBtn=document.getElementById('flip');
    const modal=document.getElementById('modal');
    const winnerText=document.getElementById('winnerText');
    const againBtn=document.getElementById('again');
    const modeSelect=document.getElementById('mode');
    const muteBtn=document.getElementById('mute');

    const moveAudio=document.getElementById('moveAudio');
    const captureAudio=document.getElementById('captureAudio');
    const winAudio=document.getElementById('winAudio');

    let state={board:[],turn:'red',selected:null,flipped:false,over:false,history:[]};
    let settings={muted:false,mode:'hotseat'};

    function initBoard(){
      const b=Array.from({length:10},()=>Array(9).fill(null));
      b[0]=['r','n','b','a','k','a','b','n','r'];
      b[2]=[null,'c',null,null,null,null,null,'c',null];
      b[3]=['p',null,'p',null,'p',null,'p',null,'p'];
      b[6]=['P',null,'P',null,'P',null,'P',null,'P'];
      b[7]=[null,'C',null,null,null,null,null,'C',null];
      b[9]=['R','N','B','A','K','A','B','N','R'];
      state.board=b;state.turn='red';state.selected=null;state.over=false;state.history=[];
      updateStatus();render();
    }

    function updateStatus(){ status.textContent = state.over? '对局结束' : `轮到：${state.turn==='red'?'红':'黑'}方`; }

    function isRed(p){return p&&p===p.toUpperCase();}
    function isBlack(p){return p&&p===p.toLowerCase();}
    function opp(p1,p2){return (isRed(p1)&&isBlack(p2))||(isBlack(p1)&&isRed(p2));}

    function render(){ boardEl.innerHTML=''; const b=state.board; for(let r=0;r<10;r++){ for(let c=0;c<9;c++){ const div=document.createElement('div'); div.className='cell'; div.dataset.r=r; div.dataset.c=c; const p=b[r][c]; if(p){ const span=document.createElement('div'); span.className='piece '+(isRed(p)?'red':'black'); span.textContent=PIECE_MAP[p]; div.appendChild(span); } div.onclick=()=>cellClick(r,c); boardEl.appendChild(div);} } if(state.selected)highlight(state.selected.r,state.selected.c); updateStatus(); }

    function cellClick(r,c){ if(state.over) return; const p=state.board[r][c]; if(state.selected){ const sel=state.selected; if(p && ((state.turn==='red'&&isRed(p)) || (state.turn==='black'&&isBlack(p)))){ state.selected={r,c}; render(); return; } const moves=genMoves(sel.r,sel.c,true); const valid=moves.find(m=>m.r===r&&m.c===c); if(valid){ doMove(sel.r,sel.c,r,c); } state.selected=null; render(); } else{ if(!p) return; if((state.turn==='red'&&isRed(p)) || (state.turn==='black'&&isBlack(p))){ state.selected={r,c}; render(); } } }

    function pushHistory(){ state.history.push(copyBoard(state.board)); if(state.history.length>200) state.history.shift(); }
    function undo(){ if(state.history.length===0) return; state.board = state.history.pop(); state.turn = state.turn==='red'?'black':'red'; state.selected=null; state.over=false; modal.style.display='none'; render(); }

    function doMove(r1,c1,r2,c2){ pushHistory(); const piece=state.board[r1][c1]; const target=state.board[r2][c2]; state.board[r2][c2]=piece; state.board[r1][c1]=null; playAudio(target? 'capture':'move'); if(target && target.toLowerCase()==='k'){ endGame(isRed(piece)?'红':'黑'); return; } state.turn = state.turn==='red'? 'black':'red'; // after move check for checkmate
      if(isCheckmate(state.turn)){
        // if side to move has no legal moves and is in check (we treat as checkmate)
        endGame(state.turn==='red'? '黑':'红'); return;
      }
      // if AI mode and it's AI's turn, schedule AI move
      if(settings.mode==='ai' && state.turn==='black' && !state.over){ setTimeout(()=>aiMove(), 350 + Math.random()*400); }
    }

    function endGame(winner){ state.over=true; winnerText.textContent = `${winner}方胜利！`; modal.style.display='flex'; playAudio('win'); }

    function playAudio(kind){ if(settings.muted) return; try{ if(kind==='move') moveAudio.play(); else if(kind==='capture') captureAudio.play(); else if(kind==='win') winAudio.play(); }catch(e){} }

    function highlight(r,c){ const cells=boardEl.children; for(let ch of cells) ch.classList.remove('sel','move','capture'); const idx=r*9+c; cells[idx].classList.add('sel'); const moves=genMoves(r,c,true); for(let m of moves){ const i=m.r*9+m.c; cells[i].classList.add(m.capture?'capture':'move'); } }

    // MOVE GENERATION (same rules as prior version) -- returns moves filtered to avoid leaving generals facing
    function genMoves(r,c, validateFacing=false){ const p=state.board[r][c]; if(!p) return []; const red=isRed(p); const moves=[]; const onBoard=(rr,cc)=>rr>=0&&rr<10&&cc>=0&&cc<9; const same=q=>q&&((red&&isRed(q))||(!red&&isBlack(q))); const oppo=q=>q&&!same(q); const add=(rr,cc)=>{ if(!onBoard(rr,cc)) return; const q=state.board[rr][cc]; if(!same(q)) moves.push({r:rr,c:cc,capture:!!q}); } const code=p.toUpperCase(); if(code==='R'){[[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>{let rr=r+dr,cc=c+dc;while(onBoard(rr,cc)){const q=state.board[rr][cc]; if(!q) moves.push({r:rr,c:cc}); else{ if(oppo(q)) moves.push({r:rr,c:cc,capture:true}); break; } rr+=dr; cc+=dc;}});} else if(code==='N'){[[ -2,-1,-1,0],[-2,1,-1,0],[2,-1,1,0],[2,1,1,0],[-1,-2,0,-1],[1,-2,0,-1],[-1,2,0,1],[1,2,0,1]].forEach(m=>{const[nr,nc,br,bc]=m; const lr=r+br,lc=c+bc; if(onBoard(r+nr,c+nc)&&!state.board[lr][lc]) add(r+nr,c+nc); }); } else if(code==='B'){[[2,2],[2,-2],[-2,2],[-2,-2]].forEach(([dr,dc])=>{ const nr=r+dr,nc=c+dc; if(!onBoard(nr,nc)) return; if((red&&nr<5)||(!red&&nr>4)) return; if(state.board[r+dr/2][c+dc/2]) return; add(nr,nc); }); } else if(code==='A'){[[1,1],[1,-1],[-1,1],[-1,-1]].forEach(([dr,dc])=>{ const nr=r+dr,nc=c+dc; if(!onBoard(nr,nc)) return; if(!inPalace(nr,nc,red)) return; add(nr,nc); }); } else if(code==='K'){[[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>{ const nr=r+dr,nc=c+dc; if(onBoard(nr,nc)&&inPalace(nr,nc,red)) add(nr,nc); }); const col=c; let rr=r+(red?-1:1); while(onBoard(rr,col)){ const q=state.board[rr][col]; if(q){ if(q.toUpperCase()==='K'&&oppo(q)) moves.push({r:rr,c:col,capture:true}); break; } rr+=(red?-1:1); } } else if(code==='C'){[[1,0],[-1,0],[0,1],[0,-1]].forEach(([dr,dc])=>{ let rr=r+dr,cc=c+dc; while(onBoard(rr,cc)&&!state.board[rr][cc]){ moves.push({r:rr,c:cc}); rr+=dr; cc+=dc; } rr+=dr; cc+=dc; while(onBoard(rr,cc)){ if(state.board[rr][cc]){ if(oppo(state.board[rr][cc])) moves.push({r:rr,c:cc,capture:true}); break; } rr+=dr; cc+=dc; } }); } else if(code==='P'){ const f=red?-1:1; if(onBoard(r+f,c)) add(r+f,c); if((red&&r<=4)||(!red&&r>=5)){ [-1,1].forEach(dc=> add(r,c+dc)); } }
      // filter out same-side capture already handled by add
      if(validateFacing){ return moves.filter(m=>{ const copy = simMove(state.board,r,c,m.r,m.c); return !generalsFacing(copy); }); }
      return moves; }

    function simMove(b,r1,c1,r2,c2){ const copy = copyBoard(b); copy[r2][c2]=copy[r1][c1]; copy[r1][c1]=null; return copy; }
    function inPalace(r,c,red){ return c>=3&&c<=5 && (red? r>=7&&r<=9 : r>=0&&r<=2); }
    function copyBoard(b){ return b.map(row=>row.slice()); }

    function generalsFacing(b){ let posR=null,posB=null; for(let r=0;r<10;r++) for(let c=0;c<9;c++){ const p=b[r][c]; if(!p) continue; if(p.toUpperCase()==='K'){ if(isRed(p)) posR={r,c}; else posB={r,c}; } } if(!posR||!posB) return false; if(posR.c!==posB.c) return false; for(let rr=Math.min(posR.r,posB.r)+1; rr<Math.max(posR.r,posB.r); rr++){ if(b[rr][posR.c]) return false; } return true; }

    function isCheckmate(color){ // if side has no legal moves (and possibly in check)
      for(let r=0;r<10;r++) for(let c=0;c<9;c++){ const p=state.board[r][c]; if(!p) continue; if((color==='red'&&isRed(p))||(color==='black'&&isBlack(p))){ const moves=genMoves(r,c,true); if(moves.length>0) return false; } } return true; }

    // AI: very simple random-move AI for black
    function aiMove(){ if(state.over) return; // collect all legal moves for black
      const movesAll=[]; for(let r=0;r<10;r++) for(let c=0;c<9;c++){ const p=state.board[r][c]; if(!p) continue; if(isBlack(p)){ const moves=genMoves(r,c,true); moves.forEach(m=>movesAll.push({r,c,m})); } } if(movesAll.length===0){ if(isCheckmate('black')) endGame('红'); return; } // prioritize captures slightly
      movesAll.sort((a,b)=> (b.m.capture?1:0) - (a.m.capture?1:0)); const choices = movesAll.slice(0, Math.max(1, Math.floor(movesAll.length*0.5))); const pick = choices[Math.floor(Math.random()*choices.length)]; doMove(pick.r,pick.c,pick.m.r,pick.m.c); render(); }

    // UI wiring
    undoBtn.onclick = ()=>{ undo(); };
    restartBtn.onclick = ()=>{ initBoard(); };
    flipBtn.onclick = ()=>{ state.flipped = !state.flipped; boardEl.style.transform = state.flipped? 'rotate(180deg)' : 'none'; boardEl.querySelectorAll('.piece').forEach(x=> x.style.transform = state.flipped? 'rotate(180deg)' : 'none'); };
    againBtn.onclick = ()=>{ initBoard(); };
    modeSelect.onchange = ()=>{ settings.mode = modeSelect.value; // if switching to AI and it's black turn, let AI play
      if(settings.mode==='ai' && state.turn==='black' && !state.over){ setTimeout(()=>aiMove(),200); } };
    muteBtn.onclick = ()=>{ settings.muted = !settings.muted; muteBtn.textContent = settings.muted? '已静音' : '静音'; };

    // basic keyboard: Z to undo
    window.addEventListener('keydown', (e)=>{ if(e.key.toLowerCase()==='z') undo(); });

    // helper: when loading, ensure audio volume low by default
    moveAudio.volume = 0.25; captureAudio.volume = 0.35; winAudio.volume = 0.5;

    // initial setup
    initBoard();
  </script>
</body>
</html>

