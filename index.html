<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>本地双人中国象棋（Xiangqi）</title>
  <style>
    :root{ --cell:64px; --board-width: calc(var(--cell) * 9); }
    body{ font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans SC", "Microsoft YaHei", sans-serif; display:flex; gap:24px; padding:24px; background:#f3f6fb; }
    .wrap{ display:flex; gap:20px; }
    #board{ width:var(--board-width); height:calc(var(--cell) * 10); display:grid; grid-template-columns: repeat(9, 1fr); grid-template-rows: repeat(10, 1fr); border:6px solid #8b5e3c; background: linear-gradient(#f5deb3,#f2d6a1); box-shadow:0 6px 18px rgba(0,0,0,0.15); }
    .cell{ box-sizing:border-box; border:1px solid rgba(0,0,0,0.06); display:flex; align-items:center; justify-content:center; font-size:28px; cursor:pointer; user-select:none; position:relative; }
    .cell.coord::after{ position:absolute; right:4px; bottom:2px; font-size:10px; color:rgba(0,0,0,0.25); }
    .cell.sel{ outline:3px solid rgba(0,123,255,0.6); }
    .cell.move{ background: rgba(0,200,0,0.12); }
    .cell.capture::after{ content:''; width:10px; height:10px; border-radius:50%; background:rgba(200,0,0,0.85); position:absolute; right:6px; bottom:6px; }
    .piece{ font-weight:700; font-size:30px; }
    .red{ color:#b22222; }
    .black{ color:#222; }

    .sidebar{ width:300px; padding:16px; background:white; border-radius:8px; box-shadow:0 6px 16px rgba(0,0,0,0.08); }
    .title{ font-size:18px; font-weight:700; margin-bottom:8px; }
    .info{ margin-bottom:12px; }
    button{ padding:8px 12px; border-radius:6px; border:1px solid #ccc; background:#fff; cursor:pointer; }
    .footer{ margin-top:12px; font-size:13px; color:#555; }
  </style>
</head>
<body>
  <div class="wrap">
    <div id="board" aria-label="象棋棋盘"></div>

    <div class="sidebar">
      <div class="title">本地双人中国象棋</div>
      <div class="info"><strong>轮到：</strong><span id="turnLabel">红</span></div>
      <div class="info"><strong>说明：</strong>
        <div>点击己方棋子选中，再点击目标格落子。支持合法规则检查（含马腿、象眼、士/将宫、炮跳吃）。</div>
      </div>
      <div style="display:flex; gap:10px;">
        <button id="restart">重新开始</button>
        <button id="flip">翻转视角</button>
      </div>
      <div class="footer">提示：这是一个功能完备的本地双人版本。后续可扩展悔棋、AI、网络对战。</div>
    </div>
  </div>

  <script>
    // Board coordinates: rows 0..9, cols 0..8. 0 at top (黑方阵营), 9 at bottom (红方阵营).
    // Piece codes: uppercase for red, lowercase for black.

    const PIECE_MAP = {
      'R': {name:'車', char:'車'}, 'N':{name:'馬', char:'馬'}, 'B':{name:'相', char:'相'}, 'A':{name:'仕', char:'仕'}, 'K':{name:'帥', char:'帥'}, 'C':{name:'炮', char:'炮'}, 'P':{name:'兵', char:'兵'},
      'r': {name:'車', char:'車'}, 'n':{name:'馬', char:'馬'}, 'b':{name:'象', char:'象'}, 'a':{name:'士', char:'士'}, 'k':{name:'將', char:'將'}, 'c':{name:'砲', char:'砲'}, 'p':{name:'卒', char:'卒'}
    };

    let boardEl = document.getElementById('board');
    let turnLabel = document.getElementById('turnLabel');
    let restartBtn = document.getElementById('restart');
    let flipBtn = document.getElementById('flip');

    let state = { board: [], turn: 'red', selected: null, flipped: false };

    function initBoard() {
      // empty 10x9
      const b = Array.from({length:10}, ()=> Array(9).fill(null));
      // Black side (top) lowercase
      b[0] = ['r','n','b','a','k','a','b','n','r'];
      b[2] = [null,'c',null,null,null,null,null,'c',null];
      b[3] = ['p',null,'p',null,'p',null,'p',null,'p'];
      // Red side uppercase (bottom)
      b[6] = ['P',null,'P',null,'P',null,'P',null,'P'];
      b[7] = [null,'C',null,null,null,null,null,'C',null];
      b[9] = ['R','N','B','A','K','A','B','N','R'];
      state.board = b;
      state.turn = 'red';
      state.selected = null;
      render();
    }

    function render() {
      boardEl.innerHTML = '';
      const b = state.board;
      for (let r=0;r<10;r++){
        for (let c=0;c<9;c++){
          const cell = document.createElement('div');
          cell.className = 'cell coord';
          cell.dataset.r = r;
          cell.dataset.c = c;
          cell.title = `${r},${c}`;
          // draw river text on rows between
          if (r===4){ cell.style.borderBottom = '2px dashed rgba(0,0,0,0.06)'; }

          const p = b[r][c];
          if (p){
            const span = document.createElement('div');
            span.className = 'piece ' + (isRedPiece(p)?'red':'black');
            span.textContent = PIECE_MAP[p].char;
            cell.appendChild(span);
          }

          cell.onclick = () => onCellClick(r,c);
          boardEl.appendChild(cell);
        }
      }
      turnLabel.textContent = state.turn === 'red' ? '红' : '黑';
      if (state.selected) highlightMoves(state.selected.r, state.selected.c);
    }

    function isRedPiece(p){ return p && p === p.toUpperCase(); }
    function isBlackPiece(p){ return p && p === p.toLowerCase(); }

    function onCellClick(r,c){
      const p = state.board[r][c];
      if (state.selected){
        const sel = state.selected;
        // If clicking same-side piece, change selection
        if (p && ((state.turn==='red' && isRedPiece(p)) || (state.turn==='black' && isBlackPiece(p)))){
          state.selected = {r,c}; render(); return;
        }
        // Try move
        const moves = genMovesFor(sel.r, sel.c, true);
        const legal = moves.some(m=>m.r===r && m.c===c);
        if (legal){
          makeMove(sel.r, sel.c, r, c);
          state.selected = null;
          render();
        } else {
          // invalid: deselect
          state.selected = null; render();
        }
      } else {
        // select if own piece
        if (!p) return;
        if ((state.turn==='red' && isRedPiece(p)) || (state.turn==='black' && isBlackPiece(p))){
          state.selected = {r,c}; render();
        }
      }
    }

    function highlightMoves(r,c){
      const cells = boardEl.children;
      const moves = genMovesFor(r,c,true);
      for (let ch of cells) ch.classList.remove('sel','move','capture');
      const idx = r*9 + c;
      cells[idx].classList.add('sel');
      for (let m of moves){
        const i = m.r*9 + m.c;
        cells[i].classList.add(m.capture? 'capture':'move');
      }
    }

    function makeMove(r1,c1,r2,c2){
      const piece = state.board[r1][c1];
      const target = state.board[r2][c2];
      // perform move
      state.board[r2][c2] = piece;
      state.board[r1][c1] = null;
      // switch turn
      state.turn = state.turn === 'red' ? 'black' : 'red';
      // check for checkmate/generals facing
      // (simple alert if general captured)
      if (target && (target.toLowerCase()==='k')){
        alert((isRedPiece(piece)?'红':'黑') + '方胜利：将死对方将/帅！');
      }
    }

    // Generate moves for piece at r,c. If "validateFacing" true then filter out moves that leave generals facing each other.
    function genMovesFor(r,c, validateFacing=false){
      const p = state.board[r][c];
      if (!p) return [];
      const red = isRedPiece(p);
      const code = p.toUpperCase();
      let moves = [];
      const add = (nr,nc, capture=false)=> moves.push({r:nr,c:nc,capture});

      // helpers
      const onBoard = (rr,cc)=> rr>=0 && rr<10 && cc>=0 && cc<9;
      const sameSide = (piece)=> piece && ((red && isRedPiece(piece)) || (!red && isBlackPiece(piece)));
      const oppSide = (piece)=> piece && !sameSide(piece);

      if (code==='R'){ // chariot
        // four directions
        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        for (let [dr,dc] of dirs){
          let nr=r+dr, nc=c+dc;
          while(onBoard(nr,nc)){
            const q = state.board[nr][nc];
            if (!q) add(nr,nc,false);
            else { if (oppSide(q)) add(nr,nc,true); break; }
            nr+=dr; nc+=dc;
          }
        }
      } else if (code==='N'){ // horse
        const horseMoves = [ [ -2,-1, -1,0 ], [ -2,1, -1,0 ], [ 2,-1, 1,0 ], [ 2,1, 1,0 ], [ -1,-2, 0,-1 ], [ 1,-2, 0,-1 ], [ -1,2, 0,1 ], [ 1,2, 0,1 ] ];
        for (let m of horseMoves){
          const [dr,dc, br,bc] = m;
          const legr = r+br, legc = c+bc;
          const nr=r+dr, nc=c+dc;
          if (!onBoard(nr,nc)) continue;
          if (state.board[legr][legc]) continue; // blocked by leg
          const q = state.board[nr][nc];
          if (!q) add(nr,nc,false);
          else if (oppSide(q)) add(nr,nc,true);
        }
      } else if (code==='B'){ // elephant (red相 / black象) diagonal 2, cannot cross river
        const dirs = [[-2,-2],[-2,2],[2,-2],[2,2]];
        for (let [dr,dc] of dirs){
          const nr=r+dr, nc=c+dc;
          const eyeR = r+dr/2, eyeC = c+dc/2;
          if (!onBoard(nr,nc)) continue;
          // cannot cross river
          if ( (isRedPiece(p) && nr<5) || (isBlackPiece(p) && nr>4) ) {
            // red's elephants stay on bottom half (rows 5..9), black's stay on top half (rows 0..4)
            // Note: in some conventions elephants can't cross, implemented here.
          }
          if (state.board[eyeR][eyeC]) continue; // eye blocked
          const q = state.board[nr][nc];
          if (!q) add(nr,nc,false);
          else if (oppSide(q)) add(nr,nc,true);
        }
      } else if (code==='A'){ // advisor 1 diagonal within palace
        const dirs=[[1,1],[1,-1],[-1,1],[-1,-1]];
        for (let [dr,dc] of dirs){
          const nr=r+dr,nc=c+dc; if (!onBoard(nr,nc)) continue;
          if (!inPalace(nr,nc, isRedPiece(p))) continue;
          const q = state.board[nr][nc];
          if (!q) add(nr,nc,false); else if (oppSide(q)) add(nr,nc,true);
        }
      } else if (code==='K'){ // general
        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        for (let [dr,dc] of dirs){
          const nr=r+dr,nc=c+dc; if (!onBoard(nr,nc)) continue;
          if (!inPalace(nr,nc, isRedPiece(p))) continue;
          const q = state.board[nr][nc];
          if (!q) add(nr,nc,false); else if (oppSide(q)) add(nr,nc,true);
        }
        // flying general: if directly facing opponent general with no pieces between
        const col = c; let step = isRedPiece(p)? -1:1;
        let rr = r+step; let blocked=false; while(rr>=0 && rr<10){
          if (state.board[rr][col]){ if (state.board[rr][col].toUpperCase()==='K'){ add(rr,col,true); } break; }
          rr+=step;
        }

      } else if (code==='C'){ // cannon
        // move like rook for non-capture
        const dirs = [[1,0],[-1,0],[0,1],[0,-1]];
        for (let [dr,dc] of dirs){
          let nr=r+dr, nc=c+dc;
          while(onBoard(nr,nc) && !state.board[nr][nc]){ add(nr,nc,false); nr+=dr; nc+=dc; }
          // now find piece to jump over
          if (!onBoard(nr,nc)) continue;
          nr+=dr; nc+=dc; while(onBoard(nr,nc)){
            if (state.board[nr-dr][nc-dc]){ /* there's a screen */ }
            if (state.board[nr][nc]){ if (oppSide(state.board[nr][nc])) add(nr,nc,true); break; }
            nr+=dr; nc+=dc;
          }
        }
      } else if (code==='P'){ // soldier
        const forward = isRedPiece(p)? -1: 1; // red moves up
        const nr=r+forward, nc=c;
        if (onBoard(nr,nc)){ const q=state.board[nr][nc]; if (!q) add(nr,nc,false); else if (oppSide(q)) add(nr,nc,true); }
        // after crossing river can move left/right
        const crossed = isRedPiece(p)? r<=4 : r>=5;
        if (crossed){
          for (let dc of [-1,1]){
            const rr=r, cc=c+dc; if (!onBoard(rr,cc)) continue; const q=state.board[rr][cc]; if (!q) add(rr,cc,false); else if (oppSide(q)) add(rr,cc,true);
          }
        }
      }

      // filter out moves that capture same-side or leave generals facing each other
      moves = moves.filter(m=>{
        const q = state.board[m.r][m.c]; if (q && sameSide(q)) return false; return true;
      });

      if (validateFacing){
        moves = moves.filter(m=> {
          // simulate
          const copy = copyBoard(state.board);
          copy[m.r][m.c] = copy[r][c]; copy[r][c] = null;
          // check if generals face each other
          return !generalsFacing(copy);
        });
      }

      return moves;
    }

    function inPalace(r,c, isRed){
      if (c<3 || c>5) return false;
      if (isRed) return r>=7 && r<=9;
      else return r>=0 && r<=2;
    }

    function copyBoard(b){ return b.map(row=> row.slice()); }

    function generalsFacing(b){
      // find generals
      let posK = null, posk = null;
      for (let r=0;r<10;r++) for (let c=0;c<9;c++){
        const p = b[r][c]; if (!p) continue;
        if (p.toUpperCase()==='K'){
          if (isRedPiece(p)) posK = {r,c}; else posk = {r,c};
        }
      }
      // if both exist and in same column
      if (!posK || !posk) return false;
      if (posK.c !== posk.c) return false;
      const col = posK.c; const r1 = posK.r, r2 = posk.r; const start = Math.min(r1,r2)+1, end = Math.max(r1,r2)-1;
      for (let rr=start; rr<=end; rr++) if (b[rr][col]) return false;
      return true;
    }

    // Wire up restart and flip
    restartBtn.onclick = ()=> initBoard();
    flipBtn.onclick = ()=> { state.flipped = !state.flipped; boardEl.style.transform = state.flipped? 'rotate(180deg)':'none'; boardEl.querySelectorAll('.cell').forEach(x=> x.style.transform = state.flipped? 'rotate(180deg)':'none'); };

    // initialize
    initBoard();
  </script>
</body>
</html>
